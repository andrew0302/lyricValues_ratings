---
title: "alpha_estimation_1.0"
author: "andrew demetriou"
date: "11/25/2021"
---


```{r setup, include=FALSE}
library('data.table') # data manipulation
library('here')       # file logistics
library('dplyr')      # logistics
library('stringr')    # manipulating strings
library('purrr')      # iteration
library('ggplot2')    # visualization
```

```{r}
# path with the actual data
data_file_path <- here("data")

# create a list with all of the files
data_files <- list.files(data_file_path)

# read in qualtrics data file
responses_dt <- fread(here(data_file_path, "annotation_number_estimation _2.2_November 28, 2021_07.51.csv"))

# remove junk on first two rows
responses_dt <- responses_dt[3:.N][`Participant Consent`=='agree', ]
```

```{r}
# get question wording for each value:
questions <- as.data.frame(colnames(fread(here(data_file_path, data_files[1]), skip=1)))[41:50,] %>%
  gsub("Please, rate the importance of the following values as a life-guiding principle for the SPEAKER of the lyrics. Use the slider in which 100 indicates that the value is of supreme importance for them, and -100 indicates that the value is completely opposed to their principles. - ", "", .)

# logical vector indicating: 
# 1) value ratings of songs
# 2) participant ID
songs <- grepl("-1_|PROLIFIC_PID", colnames(responses_dt)) 

# keep only columns in logical vector
songs_dt <- responses_dt[, ..songs]
```

```{r}
# pivot to long format
songs_dt <- melt(songs_dt, id.var="PROLIFIC_PID")

# create vector of patterns representing each value
pattern <- paste0("-1_", seq(1, 10, 1))
#create vector of song IDs
songs <- as.character(songs_dt$variable)

#remove value pattern from each song in vector
songs <- gsub(pattern[10], "", songs)
songs <- gsub(pattern[9], "", songs)
songs <- gsub(pattern[8], "", songs) 
songs <- gsub(pattern[7], "", songs) 
songs <- gsub(pattern[6], "", songs) 
songs <- gsub(pattern[5], "", songs) 
songs <- gsub(pattern[4], "", songs) 
songs <- gsub(pattern[3], "", songs) 
songs <- gsub(pattern[2], "", songs) 
songs <- gsub(pattern[1], "", songs) 

#create new variable for song_ID
#songs_dt$item_ID <- songs
songs_dt[, item_ID := ..songs]
```

```{r}
# convert column to character instead of factor
songs_dt$variable <- as.character(songs_dt$variable)
# create a vector of only unique song IDs
songs <- unique(songs_dt$item_ID)

# remove song ID from character string
# this will leave the extension, which denotes which value is rated
for(i in 1:length(songs)) {
  songs_dt$variable <- gsub(songs[i], "", songs_dt$variable)
}
```

```{r}
# get the first word of a string
pull_out_word <- function(question) {
  stringr::str_extract(question, '\\w*')
}

# convert the value in the cell to the value name
to_value <- function(x) {
         if (x== "-1_1") {x = pull_out_word(questions[1])    # power
  } else if (x== "-1_2") {x = pull_out_word(questions[2])    # achievement
  } else if (x== "-1_3") {x = pull_out_word(questions[3])    # hedonism
  } else if (x== "-1_4") {x = pull_out_word(questions[4])    # stimulation
  } else if (x== "-1_5") {x = pull_out_word(questions[5])    # self-direction
  } else if (x== "-1_6") {x = pull_out_word(questions[6])    # universalism
  } else if (x== "-1_7") {x = pull_out_word(questions[7])    # benevolence
  } else if (x== "-1_8") {x = pull_out_word(questions[8])    # tradition
  } else if (x== "-1_9") {x = pull_out_word(questions[9])    # conformity
  } else if (x== "-1_10"){x = pull_out_word(questions[10])   # security
  } else {x = NA}
}
```

```{r}
#execute recode function on relevant rows
songs_dt <- songs_dt[, variable := lapply(variable, to_value)]

# create a list of unique values
values <- unique(songs_dt$variable)
```

```{r}
#replace blank responses with explicit "0"
songs_dt$value <- sub("^$", "0", songs_dt$value)
songs_dt$value <- as.numeric(songs_dt$value)

#rename participant ID
setnames(songs_dt, "PROLIFIC_PID", "participant_ID")
```

```{r}
# somehow the variable column became a list
# this turns it back into a character vector
songs_dt$variable <- as.character(songs_dt$variable)

# pivot to wide format, where each value is now its own column
songs_dt <- dcast(songs_dt, participant_ID + item_ID ~ variable, value.var = "value")
```

```{r}
pivot_datatable <- function(dt, column){
  
    #dt <- rename_columns(dt)
  
    # select ID columns
    # and the variable that will define the dataset
    dt[, c("participant_ID", "item_ID", ..column)] %>%
    
    # restructure dataframe so that columns are the individual items
    # and the values in the columns are the scores for the variable
    dcast(., participant_ID ~ item_ID)
    
}
```

```{r}
#pivot_datatable(songs_dt, "ACHIEVEMENT")
```


```{r}
make_list_of_pivoted_datatables <- function(dt, values){
  
  #get a list of column names,which are the variables in the dataset
  values <- colnames(dt)
  values <- values[!values %in% c("participant_ID", "item_ID")]
  
  
  dt_list <- lapply(values, function(x){
      #pivot the dataframe
      pivot_datatable(dt, x)
    
  })
  
  setNames(dt_list, values)
}
```

```{r}
# t<- make_list_of_pivoted_datatables(songs_dt, values)
```
```{r}
get_alpha_dt <- function(dt, n) {
  
  #setDT(dt)
  
  #remove subject_ID column
  #compute means of each column
  #transpose to a column
  canon <- dt[, -c("participant_ID")][, lapply(.SD, mean)] %>% t()
  #canon <- canon[, subject_ID := NULL][, lapply(.SD, mean)] %>% t()
    
  #sample n rows from the databale
  data_sample <- sapply(dt[, -c("participant_ID")], sample, n) %>%
    # coax to data frame, then to data table
    as.data.frame(.) %>% setDT(.)
  
  # calculate cronbach's alpha
  capture.output(suppressWarnings(a <- psych::alpha(t(data_sample))))
  #a <- psych::alpha(t(data_sample))
  alpha <- a$total["std.alpha"] %>% pluck(1)

  # calculate mean sample ratings
  sample_means <- data_sample[,lapply(.SD, mean, na.rm=TRUE)] %>% t()
  
  # calculate correlation between sample mean ratings and canon
  r <- cor(sample_means, canon)[[1,1]]
  
  # return relevant data
  data.table(
    n = n,
    alpha = alpha,
    r = r
  )
}
```

```{r}
#get_alpha_dt(t[[1]], 20)
```
```{r}
samples_of_alphas <- function(
  dt, 
  n_samples = 10, 
  n_raters = seq(5, 50, by = 5)
  ){
  #draw n_raters number of samples n_samples number of times
  alpha_tibble <- rep(n_raters, each = n_samples) %>% 
    purrr::map_df( function(n) { 
      get_alpha_dt(dt, n)
    })
  return(alpha_tibble)
}
```

```{r}
#samples_of_alphas_dt(t[[1]])
```
```{r}
make_list_of_alpha_tibbles_dt <- function(
  dt, 
  n_samples = 10, 
  n_raters = seq(5, 50, by = 5)
  ){
  
  
  #get a list of column names which are the variables in the dataset
  column_list <- colnames(dt %>% select(-participant_ID, -item_ID))
    canon <- dt[, -c("participant_ID")][, lapply(.SD, mean)] %>% t()

  #create a dt for every dependent variables
  dt_list <- dt %>% 
    make_list_of_pivoted_datatables() 
  
  #create an empty list
  alpha_tibble_list <- list()

  #iterate over the list of variable names
  counter <- 1
  for(i in column_list){

    #for each variable, make a tibble of resampled alphas
    alpha_tibble_list[[counter]] <- samples_of_alphas(dt_list[[counter]], n_samples, n_raters)
      
    #name the tibble after the variable
    names(alpha_tibble_list)[[counter]] <- column_list[counter]
    
    #update counter
    counter <- counter+1
  }
  return(alpha_tibble_list)
}
```

```{r}
#s <- make_list_of_alpha_tibbles_dt(songs_dt, 30)
save(s, file = "list_of_alpha_tibbles.rds")
```

```{r}
plot_alphas <- function(alpha_dt){
  ggplot(alpha_dt) +
    geom_vline(xintercept = 0.8, color = "grey50" ) +
    geom_density(aes(alpha, colour = as.factor(n))) + 
    xlim(0, 1) +
    labs(title = "Distribution of Alphas by Rater N\n", 
       color = "Number of raters\n") +
    theme_minimal()
}
```

```{r}
plot_alphas(s[[1]])
```
```{r}
list_of_plots <- lapply(s, plot_alphas)
```

```{r}
list_of_plots
```

