---
title: "item analysis"
author: "andrew demetriou"
date: "07/12/2021"
---


```{r setup, include=FALSE}
library('here')            # file logistics
library('data.table')      # data manipulation
library('dplyr')           # data manipulation

library('ggplot2')         # visualization
library('ggridges')        # joyplot visualization
library('shiny')           # interactive visualization
library('DT')              # interactive tables

library("broom.mixed")     # data wrangling
library("broom")
library("lme4")            # estimating random effects

library('parallel')        # set the number of usable cores
library('future.apply')    # parallelize apply() functions

# ensure this script returns the same results on each run
set.seed(42) #the answer to life, the universe, and everything

#compute number of cores in cluster for parallelization
workers <- detectCores()-1
future::plan(multisession, workers = workers)

# organize qualtrics output
source("data_file_re-shape_1.0.R")

# extract random effects and confidence intervals
source("descriptives_function_1.6.R")
```

```{r}
# path with the actual data
data_file_path <- here("data")

# file name as a string
file_name <- "annotation_number_estimation _2.2_November 28, 2021_07.51.csv"

# read in qualtrics data file
responses_dt <- fread(here(data_file_path, file_name)) %>%
  data_file_reshape(., file_name)
```

```{r}
random_effects_dt <- assemble_random_effects_dt(responses_dt)
```

```{r}
random_effects_dt %>%
  ggplot(aes(model, item_ID, color = model)) +
  geom_errorbar(aes(ymin = item_ID_lower, ymax = item_ID_higher), position="dodge") +
  geom_point(size = 2) + 
  theme(axis.text.x=element_blank(), axis.title.x=element_blank()) +
  scale_y_continuous(limits = c(0, 40))
```

```{r}
random_effects_dt %>%
  ggplot(aes(model, participant_ID, color = model)) +
  geom_errorbar(aes(ymin = participant_ID_lower, ymax = participant_ID_higher), position="dodge") +
  geom_point(size = 2) + 
  theme(axis.text.x=element_blank(), axis.title.x=element_blank()) +
  scale_y_continuous(limits = c(0, 40))
```

```{r}
responses_dt %>% group_by(item_ID) %>%
  ggplot(aes(x=STIMULATION, y=item_ID, fill=0.5 -abs(0.5 -stat(ecdf)))) +
  stat_density_ridges(geom="density_ridges_gradient", calc_ecdf=TRUE, show.legend=FALSE) +
  scale_fill_viridis_c(option="C") #+
#  theme_ridges()
```

```{r}
responses_dt <- as.data.frame(responses_dt)

list_of_value_by_song_plots <- lapply(3:12, function(i){
  ggplot(responses_dt, aes(x=responses_dt[,i], y=item_ID, fill=0.5 -abs(0.5 -stat(ecdf)))) +
  stat_density_ridges(geom="density_ridges_gradient", calc_ecdf=TRUE, show.legend=FALSE) +
  scale_fill_viridis_c(option="C") #+
#  theme_ridges()
})

values<-c("ACHIEVEMENT", "BENEVOLENCE", "CONFORMITY", "HEDONISM", 
          "POWER", "SECURITY", "SELF", "STIMULATION", 
          "TRADITION",  "UNIVERSALISM")

names(list_of_value_by_song_plots) <- values
```

```{r}
responses_dt <- setDT(responses_dt)

item_mean <- aggregate(responses_dt[,3:12], list(responses_dt$item_ID), mean)
setDT(item_mean)
item_mean[, stat := 'mean']
colnames <- colnames(item_mean)

item_sd <- aggregate(responses_dt[,3:12], list(responses_dt$item_ID), sd)
setDT(item_sd)
item_sd[, stat := 'sd']

setnames(item_mean, "Group.1", "item_ID")
setnames(item_sd,   "Group.1", "item_ID")

responses_dt <- as.data.frame(responses_dt)
```

```{r}
for(i in length(colnames(item_mean)))

mean(item_mean$ACHIEVEMENT)
mean(item_mean$BENEVOLENCE)
mean(item_mean$CONFORMITY)
mean(item_mean$HEDONISM)
mean(item_mean$POWER)
mean(item_mean$SECURITY)
mean(item_mean$SELF)
mean(item_mean$STIMULATION)
mean(item_mean$TRADITION)
mean(item_mean$UNIVERSALISM)

colnames(item_mean)
```

```{r}
ui <- fluidPage(
  titlePanel("Distribution of Ratings per song by Value"),
  
  # drop down menu to display the values
  selectInput('choice', 'select value', choice = values), 
  
  #plot song plot
  plotOutput('value_by_song_plots'),
  
  #display item_means
  DT::DTOutput('item_mean'),
  
  #display item_sds
  DT::DTOutput('item_sd')
)

server <- function(input, output, session){
  
  # render the plots; alpha distribution by n
  output$value_by_song_plots <- renderPlot({
      #note that plots are pre-computed
      list_of_value_by_song_plots[input$choice]
  })
  
  # write a function that receives the input
  # and then filters dataframe column
  display_summary <- function(dt) {
    dt %>% select(stat, item_ID, input$choice)
  }
  
  #print table with item means
  output$item_mean <- renderDataTable({display_summary(item_mean)})
  
  #print table with item SDs
  output$item_sd   <- renderDataTable({display_summary(item_sd)})

  }
shinyApp(ui=ui, server=server)
```
```{r}
item_plot_dt <- as.data.table(responses_dt) %>% melt(., id.vars = c("participant_ID", "item_ID"), measure.vars = c("ACHIEVEMENT","BENEVOLENCE", "CONFORMITY", "HEDONISM", "POWER", "SECURITY", "SELF", "STIMULATION", "TRADITION", "UNIVERSALISM"))

items <- unique(item_plot_dt$item_ID)
```

```{r}
item_plot_function <- function(item_plot_dt, item){
  item_plot_dt %>% filter(., item_ID == item) %>%
    ggplot(., aes(x=value, y=variable, fill=0.5 -abs(0.5 -stat(ecdf)))) +
    stat_density_ridges(geom="density_ridges_gradient", calc_ecdf=TRUE, show.legend=FALSE) +
    scale_fill_viridis_c(option="C")
}
#item_plot_function(item_plot_dt, '151085454')
```

```{r}
list_of_song_by_value_plots <- lapply(items, function(i) item_plot_function(item_plot_dt, i))

names(list_of_song_by_value_plots) <- items
```

```{r}
confidence_dt <- fread(here(data_file_path, file_name))

confidence_ratings <- grepl("-c|PROLIFIC_PID", colnames(confidence_dt))

confidence_dt <- confidence_dt[,..confidence_ratings][3:.N]
```

```{r}
confidence_dt[confidence_dt == "Extremely unconfident"] <- 1
confidence_dt[confidence_dt == "Very unconfident"] <- 2
confidence_dt[confidence_dt == "Somewhat unconfident"] <- 3
confidence_dt[confidence_dt == "Neither confident nor unconfident"] <- 4
confidence_dt[confidence_dt == "Somewhat confident"] <- 5
confidence_dt[confidence_dt == "Very confident"] <- 6
confidence_dt[confidence_dt == "Extremely confident"] <- 7
```

```{r}
#colnames <- colnames(confidence_dt) 
#gsub("-c", "", colnames)
colnames(confidence_dt) <- gsub("-c", "", colnames(confidence_dt))
cols <- colnames(confidence_dt)
cols <- cols[1:length(cols)-1]
```

```{r}
confidence_dt <- melt(confidence_dt, id.vars = c("PROLIFIC_PID"), measure.vars = 1:20) 
```
```{r}
confidence_dt %>% 
  ggplot(aes(x=as.numeric(value), y=variable, fill=0.5 -abs(0.5 -stat(ecdf)))) +
    stat_density_ridges(geom="density_ridges_gradient", calc_ecdf=TRUE, show.legend=FALSE) +
    scale_fill_viridis_c(option="C") +
  xlab("Self-Reported Confidence in annotations")
```


```{r}
ui <- fluidPage(
  titlePanel("Distribution of Ratings per Value by Song"),
  
  # drop down menu to display the values
  selectInput('choice', 'select song', choice = items), 
  
  #plot song plot
  plotOutput('song_by_value_plots'),
  
)

server <- function(input, output, session){
  
  # render the plots; alpha distribution by n
  output$song_by_value_plots <- renderPlot({
      #note that plots are pre-computed
      list_of_song_by_value_plots[input$choice]
  })
  
  # write a function that receives the input
  # and then filters dataframe column
  display_summary <- function(dt) {
    dt %>% select(stat, item_ID, input$choice)
  }

  }
shinyApp(ui=ui, server=server)
```




